<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Programming Paradigms</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/blood.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
                <section>
                    <h2> Programming Paradigms </h2>
                    <small>Mikail Khan</small>
                </section>

                <section>
                    <h2> Objectives </h2>
                    <hr>
                    <p>
                        <ul>
                            <li> What is a programming paradigm? </li>
                            <li> Summary of the main paradigms </li>
                            <li> How paradigms can influence your problem solving thought process </li>
                        </ul>
                    </p>
                </section>

                <section>
                    <section> <h2> What is a Programming Paradigm? </h2> </section>
                    <section>
                        <q cite="Wikipedia">
                            Programming paradigms are a way to classify programming 
                            languages based on their features. Languages can be classified 
                            into multiple paradigms.
                        </q>
                        <br>
                        - Wikipedia
                    </section>
                    <section>
                        <h3> Programming Paradigm Examples </h3>
                        <hr>
                        <p>
                            <ul>
                                <li> 
                                    Imperative Programming 
                                    <ul>
                                        <li> Procedural Programming </li>
                                        <li> Object-Oriented Programming </li>
                                    </ul>
                                </li>
                                <li> Functional Programming </li>
                                <li> Logic Programming </li>
                                <li> Symbolic Programming </li>
                            </ul>
                        </p>
                    </section>
                </section>

                <section>
                    <section> <h2> Imperative Programming </h2> </section>
                    <section>
                        <h3> Imperative Programming </h3>
                        <p>
                            In imperative programming languages, the programmer writes a list of
                            instructions for the computer to follow.
                        </p>
                        <p>
                        <a href="#/procedural">Procedural</a> and <a href="#/oop">Object-Oriented</a> languages are both types of imperative programming.
                        </p>
                    </section>
                    <section>
                        <h3> Imperative Language Examples </h3>
                        <hr>
                        <p>
                            <ul>
                                <li> C, C++ </li>
                                <li> Java </li>
                                <li> Python </li>
                                <li> x86 Assembly </li>
                            </ul>
                        </p>
                    </section>
                </section>

                <section>
                    <section id="procedural"> 
                        <h2> Procedural Programming </h2>
                        <hr>
                        <p>
                            In Procedural languages, instructions are grouped into procedures to facilitate code reuse.
                        </p>
                        <p>
                            Oftentimes, procedures modify state but do not return anything.
                        </p>
                    </section>
                    <section>
                        <h3> Procedural Languages </h3>
                        <hr>
                        <p>
                            <ul>
                                <li> C </li>
                                <li> SQL </li>
                                <li> Bash/Powershell </li>
                                <li> x86 Assembly </li>
                            </ul>
                        </p>
                    </section>
                    <section>
                        <h3> Procedural Code </h3>
                        <hr>
                        <div class="r-stack">
                            <div class="fragment fade-out">
                                <pre>
                                    <code data-trim class="c">
                                        void fizzbuzz(int n) {
                                            for (int i = 0; i < n; i++) {
                                                if (i % 3 == 0) 
                                                    printf("Fizz");
                                                if (i % 5 == 0)
                                                    printf("Buzz");
                                                if (!(i % 3 == 0 || i % 5 == 0))
                                                    printf("%d", i);
                                                printf("\n");
                                            }
                                        }
                                    </code>
                                </pre>
                                <ul>
                                    <li> 
                                        Procedure interfaces with IO (modifies state) but doesn't return anything
                                    </li>
                                    <li> Uses a for-loop </li>
                                    <li> <code>if</code> statements don't return anything </li>
                                </ul>
                            </div>
                            <div class="fragment fade-in">
                                <pre>
                                    <code data-trim class="c">
                                        struct fizzbuzz_opts {
                                            int fizz_n;
                                            int buzz_n;
                                            int max;
                                        };

                                        void fizzbuzz(struct fizzbuzz_opts opts) { 
                                            ... 
                                        }
                                    </code>
                                </pre>
                                <ul>
                                    <li> Structs don't contain any logic, just data </li>
                                    <li> Procedure accepts structs as arguments </li>
                                </ul>
                            </div>
                        </div>
                    </section>
                </section>

                <section>
                    <section id="oop"> 
                        <h2> Object-Oriented Programming </h2>
                        <hr>
                        <p>
                            In OOP languages, code is grouped into classes that identify which state the code accesses.
                        </p>
                    </section>
                    <section>
                        <h3> OOP Languages </h3>
                        <hr>
                        <p>
                            <ul>
                                <li> Java </li>
                                <li> C++ </li>
                                <li> Python </li>
                            </ul>
                        </p>
                    </section>
                    <section>
                        <h3> OOP Code </h3>
                        <hr>
                        <div class="r-stack">
                            <div class="fragment fade-out">
                                <pre>
                                    <code data-trim class="java">
                                        void fizzbuzz(int n) {
                                            for (int i = 0; i < n; i++) {
                                                if (i % 3 == 0) 
                                                    System.out.print("Fizz");
                                                if (i % 5 == 0)
                                                    System.out.print("Buzz");
                                                if (!(i % 3 == 0 || i % 5 == 0))
                                                    System.out.printf("%d", i);
                                                System.out.println();
                                            }
                                        }
                                    </code>
                                </pre>
                                <ul>
                                    <li> Almost exactly the same in Java as C </li>
                                    <li> <code>print</code> is a method of the <code>PrintStream</code> class, of which <code>System.out</code> is an instance.
                                </ul>
                            </div>
                            <div class="fragment fade-in">
                                <pre>
                                    <code data-trim class="java">
                                        class FizzBuzz {
                                            private int fizzN;
                                            private int buzzN;
                                            private int max;

                                            void fizzBuzz() {
                                                ...
                                            }
                                        }
                                    </code>
                                </pre>
                                <ul>
                                    <li> The class contains data format and logic </li>
                                    <li> Within the method, the <code>this</code> keyword accesses instance data </li>
                                </ul>
                            </div>
                        </div>
                    </section>
                </section>

                <section>
                    <section id="fp"> 
                        <h2> Functional Programming </h2>
                        <hr>
                        <div class="r-stack">
                            <p class="fragment fade-out">
                                In Functional programming, programs are a single expression formed by the composition of pure functions.
                            </p>
                            <ul class="fragment fade-in">
                                <li> No mutability (no loops) </li>
                                <li> Algebraic Data Types (ADTs) </li>
                                <li> Often use ML based syntax </li>
                            </ul>
                        </div>
                    </section>
                    <section>
                        <h3> FP Languages </h3>
                        <hr>
                        <p>
                            <ul>
                                <li> Haskell </li>
                                <li> OCaml </li>
                                <li> Elixir </li>
                                <li> Microsoft Excel </li>
                            </ul>
                        </p>
                    </section>
                    <section>
                        <h3> Functional Code </h3>
                        <hr>
                        <div class="r-stack">
                            <div class="fragment fade-out">
                                <pre>
                                    <code data-trim class="haskell">
                                        fizzbuzz :: Int -> String
                                        fizzbuzz n
                                            | divisible_by 3 && divisible_by 5 = "FizzBuzz"
                                            | divisible_by 5 = "Buzz"
                                            | divisible_by 3 = "Fizz"
                                            | otherwise = show x
                                            where divisible_by = (==0) . (rem n)

                                        main = mapM_ putStrLn $ map fizzbuzz [1..100]
                                    </code>
                                </pre>
                                <ul>
                                    <li> <code>fizzbuzz</code> function is pure, IO is restricted to <code>main</code> </li>
                                    <li> 
                                        Makes use of higher order functions (<code>map</code>), currying (<code>divisible_by</code>), 
                                        and function composition (<code>.</code>)
                                    </li>
                                    <li> Functions are atomic and composable </li>
                                </ul>
                            </div>
                            <div class="fragment fade-in-then-out">
                                <pre>
                                    <code data-trim class="elixir">
                                        def fizzbuzz(n) do
                                            divisible_by = fn x -> rem(n, x) == 0 end
                                            cond do
                                                  divisible_by.(3) && divisible_by.(5) -> "FizzBuzz"
                                                  divisible_by.(5) -> "Buzz"
                                                  divisible_by.(3) -> "Fizz"
                                                  true -> to_string(n)
                                            end
                                        end

                                        def main() do
                                            1..100 |> Enum.map(fizzbuzz) |> Enum.each(IO.puts())
                                        end
                                    </code>
                                </pre>
                                <ul>
                                    <li> Elixir uses Ruby syntax and is not purely functional because it allows side effects </li>
                                    <li> Pipe operator is similar to Bash, replaces <code>.function()</code> chains </li>
                                </ul>
                            </div>
                            <div class="fragment fade-in-then-out">
                                <pre>
                                    <code data-trim class="haskell">
                                        data FizzBuzzOpts = FizzBuzzOpts {
                                            fizzN :: Int,
                                            buzzN :: Int,
                                            fizzBuzzMax :: Int,
                                         }

                                        fizzbuzz :: FizzBuzzOpts -> [String]
                                        fizzbuzz opts = ...
                                    </code>
                                </pre>
                                <ul>
                                    <li> Mostly direct translation from procedural </li>
                                    <li> "Record Syntax" can only be accessed through pattern matching or accessor methods </li>
                                </ul>
                            </div>
                            <div class="fragment fade-in-then-out">
                                <pre>
                                    <code data-trim class="haskell">
                                        data Fizz = Fizz Int
                                        data Buzz = Buzz Int
                                        data Max  = Max Int

                                        fizzbuzz :: Fizz -> Buzz -> Max -> [String]
                                    </code>
                                </pre>
                                <ul>
                                    <li> Similar to named/keyword arguments </li>
                                    <li> A bit verbose </li>
                                    <li> Can be flexible for more advanced applications using sum types and pattern matching </li>
                                </ul>
                            </div>
                            <div class="fragment fade-in">
                                <pre>
                                    <code data-trim class="haskell">
                                        data Bounds = Max Int | Range Int Int

                                        fizzbuzz :: Int -> Int -> Bounds -> [String]
                                        fizzbuzz fizzN buzzN (Max m) = ...
                                        fizzbuzz fizzN buzzN (Range start end) = ...
                                    </code>
                                </pre>
                                <ul>
                                    <li> Specify either a <code>Max</code> or a <code>Range</code> </li>
                                    <li> Code is cleanly divided through pattern matching </li>
                                </ul>
                            </div>
                        </div>
                    </section>
                    <section>
                        <div class="r-stack">
                            <div class="fragment fade-out">
                                <pre>
                                    <code data-trim class="haskell" data-line-numbers>
                                        data Nat = Z | S Nat deriving Show
                                        zero = Z
                                        one = S Z
                                        two = S one
                                        three = S two

                                        add :: Nat -> Nat -> Nat
                                        add Z n = n
                                        add (S a) b = add a (S b)

                                        sub :: Nat -> Nat -> Nat
                                        sub n Z = n
                                        sub (S a) (S b) = sub a b 
                                    </code>
                                </pre>
                                <ul>
                                    <li> At its core, every complex type is raw data identified by a constructor </li>
                                </ul>
                            </div>
                            <div class="fragment fade-in-then-out">
                                <pre>
                                    <code data-trim class="haskell" data-line-numbers>
                                        data Shape
                                            = Circle Float
                                            | Rectangle Float Float
                                            | Triangle Float Float

                                        area :: Shape -> Float
                                        area (Circle r) = 3.14 * r * r
                                        area (Rectangle w h) = w * h
                                        area (Triangle b h) = b * h / 2
                                    </code>
                                </pre>
                                <ul>
                                    <li> Algebraic data types include Sum Types (OR) as well as Product Types (And) </li>
                                    <li> In OOP, this is generally done with abstract classes. </li>
                                    <li> In procedural languages, this can be done with tagged unions </li>
                                </ul>
                            </div>
                            <div class="fragment fade-in-then-out">
                                <pre>
                                    <code data-trim class="haskell">
                                        data Fizz = Fizz Int
                                        data Buzz = Buzz Int
                                        data Max  = Max Int

                                        fizzbuzz :: Fizz -> Buzz -> Max -> [String]
                                    </code>
                                </pre>
                                <ul>
                                    <li> Similar to named/keyword arguments </li>
                                    <li> A bit verbose </li>
                                    <li> Can be flexible for more advanced applications using sum types and pattern matching </li>
                                </ul>
                            </div>
                            <div class="fragment fade-in-then-out">
                                <pre>
                                    <code data-trim class="haskell">
                                        data Bounds = Max Int | Range Int Int

                                        fizzbuzz :: Int -> Int -> Bounds -> [String]
                                        fizzbuzz fizzN buzzN (Max m) = ...
                                        fizzbuzz fizzN buzzN (Range start end) = ...
                                    </code>
                                </pre>
                                <ul>
                                    <li> Specify either a <code>Max</code> or a <code>Range</code> </li>
                                    <li> Code is cleanly divided through pattern matching </li>
                                </ul>
                            </div>
                            <div class="fragment fade-in-then-out">
                                <pre>
                                    <code data-trim class="haskell">
                                        data BinOp
                                            = Add
                                            | Sub
                                            | Mul
                                            | Div

                                        data Expr = AtomicExpr Int | BinaryExpr BinOp Expr Expr

                                        eval :: Expr -> Int
                                        eval (AtomicExpr v) = v
                                        eval (BinaryExpr Add lhs rhs) = (eval lhs) + (eval rhs)
                                        eval (BinaryExpr Sub lhs rhs) = (eval lhs) - (eval rhs)
                                        eval (BinaryExpr Mul lhs rhs) = (eval lhs) * (eval rhs)
                                        eval (BinaryExpr Div lhs rhs) = (eval lhs) / (eval rhs)
                                    </code>
                                </pre>
                            </div>
                            <div class="fragment fade-in-then-out">
                                <pre>
                                    <code data-trim class="java">
                                        enum BinOp {
                                            Add,
                                            Sub,
                                            Mul,
                                            Div,
                                        }

                                        abstract class Expr {
                                            int eval();

                                            abstract class AtomicExpr extends Expr {
                                                int val;

                                                int eval() {
                                                    return this.val;
                                                }
                                            }

                                            abstract class BinaryExpr extends Expr {
                                                BinOp op;
                                                Expr lhs;
                                                Expr rhs;

                                                int eval() {
                                                    return switch (op) {
                                                        case BinOp.Add -> lhs.eval() + rhs.eval();
                                                        case BinOp.Sub -> lhs.eval() - rhs.eval();
                                                        case BinOp.Mul -> lhs.eval() * rhs.eval();
                                                        case BinOp.Div -> lhs.eval() / rhs.eval();
                                                    };
                                                }
                                            }
                                        }
                                    </code>
                                </pre>
                            </div>
                            <div class="fragment fade-in-then-out">
                                <pre>
                                    <code data-trim class="scala">
                                        abstract class BinOp
                                        case object Add extends BinOp
                                        case object Sub extends BinOp
                                        case object Mul extends BinOp
                                        case object Div extends BinOp

                                        case class AtomicExpr(value: Int) extends Expr
                                        case class BinaryExpr(op: BinOp, lhs: Expr, rhs: Expr) extends Expr
                                        abstract class Expr {
                                            def eval(): Int = {
                                                this match {
                                                    case AtomicExpr(value) => value
                                                    case BinaryExpr(Add, lhs, rhs) => lhs.eval() + rhs.eval()
                                                    case BinaryExpr(Sub, lhs, rhs) => lhs.eval() - rhs.eval()
                                                    case BinaryExpr(Mul, lhs, rhs) => lhs.eval() * rhs.eval()
                                                    case BinaryExpr(Div, lhs, rhs) => lhs.eval() / rhs.eval()
                                                }
                                            }
                                        }
                                    </code>
                                </pre>
                            </div>
                        </div>
                    </section>
                </section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
